# 代码优化计划-异步与错误处理专项

> 本文是 [代码优化计划.md](代码优化计划.md) 的补充文档，专门针对 `async void` 修复和错误处理统一提供逐文件、逐方法的详细修改指南。

---

## 目录

1. [async void 完整修复清单](#1-async-void-完整修复清单)
2. [错误处理分级策略](#2-错误处理分级策略)
3. [空 catch 修复清单](#3-空-catch-修复清单)
4. [全局异常兜底机制](#4-全局异常兜底机制)
5. [CancellationToken 规范化](#5-cancellationtoken-规范化)
6. [重试策略建议](#6-重试策略建议)

---

## 1. async void 完整修复清单

### 1.1 MainWindowViewModel.Insight.cs

**方法：`SendInsight(string userQuestion, ...)`（约第 129 行）**

```csharp
// ❌ 改造前
private async void SendInsight(string userQuestion, string systemPrompt)
{
    try
    {
        IsInsightBusy = true;
        _insightCts = new CancellationTokenSource();
        // ... AI 请求逻辑
    }
    catch (OperationCanceledException) { }
    catch (HttpRequestException ex)
    {
        InsightResult = $"网络错误: {ex.Message}";
    }
    catch (Exception ex)
    {
        InsightResult = $"错误: {ex.Message}";
    }
    finally
    {
        IsInsightBusy = false;
    }
}

// ✅ 改造后
private async Task SendInsightAsync(string userQuestion, string systemPrompt)
{
    try
    {
        IsInsightBusy = true;
        _insightCts = new CancellationTokenSource();
        // ... AI 请求逻辑（保持不变）
    }
    catch (OperationCanceledException)
    {
        _logger?.LogDebug("Insight 请求已取消");
    }
    catch (HttpRequestException ex)
    {
        _logger?.LogWarning(ex, "Insight 网络请求失败");
        InsightResult = $"网络错误: {ex.Message}";
    }
    catch (Exception ex)
    {
        _logger?.LogError(ex, "Insight 请求异常");
        InsightResult = $"错误: {ex.Message}";
    }
    finally
    {
        IsInsightBusy = false;
    }
}

// 命令绑定改为:
[RelayCommand]
private Task SendInsight(string userQuestion) => SendInsightAsync(userQuestion, _systemPrompt);
```

---

### 1.2 MainWindowViewModel.TranslationAndUi.cs

**方法：`StartTranslation()`（约第 250 行）**

```csharp
// ❌ 改造前
private async void StartTranslation()
{
    try
    {
        StatusMessage = "正在启动翻译...";
        await _speechTranslationService.StartTranslationAsync(...);
        StatusMessage = "翻译中";
        IsTranslating = true;
    }
    catch (Exception ex)
    {
        StatusMessage = $"启动失败: {ex.Message}";
    }
}

// ✅ 改造后
private async Task StartTranslationAsync()
{
    try
    {
        StatusMessage = "正在启动翻译...";
        await _speechTranslationService.StartTranslationAsync(...);
        StatusMessage = "翻译中";
        IsTranslating = true;
    }
    catch (InvalidOperationException ex)
    {
        // 配置问题（如未选择订阅）
        StatusMessage = $"配置错误: {ex.Message}";
    }
    catch (HttpRequestException ex)
    {
        // 网络/Azure 连接问题
        StatusMessage = $"连接失败: {ex.Message}";
    }
    catch (Exception ex)
    {
        StatusMessage = $"启动失败: {ex.Message}";
        _logger?.LogError(ex, "翻译启动异常");
    }
}
```

**方法：`StopTranslation()`（约第 270 行）**

```csharp
// ❌ 改造前
private async void StopTranslation()
{
    await _speechTranslationService.StopTranslationAsync();
    IsTranslating = false;
    StatusMessage = "已停止";
}

// ✅ 改造后
private async Task StopTranslationAsync()
{
    try
    {
        await _speechTranslationService.StopTranslationAsync();
    }
    catch (Exception ex)
    {
        _logger?.LogWarning(ex, "停止翻译时出现异常（非致命）");
    }
    finally
    {
        IsTranslating = false;
        StatusMessage = "已停止";
    }
}
```

---

### 1.3 MainWindowViewModel.ReviewBatch.cs

**方法：`GenerateReviewSummary()`（约第 175 行）**

```csharp
// ✅ 改造后
private async Task GenerateReviewSummaryAsync()
{
    if (string.IsNullOrWhiteSpace(CurrentSessionContent))
    {
        StatusMessage = "没有可分析的内容";
        return;
    }

    try
    {
        IsReviewBusy = true;
        StatusMessage = "正在生成审查摘要...";
        var result = await _aiInsightService.AnalyzeAsync(
            CurrentSessionContent,
            _config.AiConfig.ReviewPrompt,
            _reviewCts.Token);
        ReviewResult = result;
        StatusMessage = "审查摘要已生成";
    }
    catch (OperationCanceledException)
    {
        StatusMessage = "已取消审查";
    }
    catch (Exception ex)
    {
        StatusMessage = $"审查失败: {ex.Message}";
        _logger?.LogError(ex, "审查摘要生成失败");
    }
    finally
    {
        IsReviewBusy = false;
    }
}
```

**方法：`GenerateAllReviewSheets()`（约第 220 行）**

```csharp
// ✅ 改造后
private async Task GenerateAllReviewSheetsAsync()
{
    try
    {
        IsReviewBusy = true;
        var tasks = _reviewSheetPresets.Select(preset =>
            GenerateSingleReviewSheetAsync(preset, _reviewCts.Token));
        await Task.WhenAll(tasks);
        StatusMessage = $"已生成 {_reviewSheetPresets.Count} 个审查表";
    }
    catch (OperationCanceledException)
    {
        StatusMessage = "批量审查已取消";
    }
    catch (Exception ex)
    {
        StatusMessage = $"批量审查失败: {ex.Message}";
        _logger?.LogError(ex, "批量审查表生成失败");
    }
    finally
    {
        IsReviewBusy = false;
    }
}
```

**方法：`GenerateSpeechSubtitle()`（约第 285 行）**

```csharp
// ✅ 改造后
private async Task GenerateSpeechSubtitleAsync()
{
    try
    {
        StatusMessage = "正在生成语音字幕...";
        // ... 保持现有逻辑
        StatusMessage = "语音字幕已生成";
    }
    catch (OperationCanceledException)
    {
        StatusMessage = "字幕生成已取消";
    }
    catch (Exception ex)
    {
        StatusMessage = $"字幕生成失败: {ex.Message}";
        _logger?.LogError(ex, "语音字幕生成失败");
    }
}
```

**方法：`GenerateBatchSpeechSubtitle()`（约第 330 行）**

```csharp
// ✅ 改造后
private async Task GenerateBatchSpeechSubtitleAsync()
{
    try
    {
        StatusMessage = "正在批量生成字幕...";
        var semaphore = new SemaphoreSlim(_batchConcurrencyLimit);
        var tasks = _batchQueue.Select(item =>
            ProcessBatchItemWithSemaphoreAsync(item, semaphore, _batchCts.Token));
        await Task.WhenAll(tasks);
        StatusMessage = $"批量字幕生成完成: {_batchQueue.Count} 个文件";
    }
    catch (OperationCanceledException)
    {
        StatusMessage = "批量处理已取消";
    }
    catch (Exception ex)
    {
        StatusMessage = $"批量处理失败: {ex.Message}";
        _logger?.LogError(ex, "批量字幕生成失败");
    }
}
```

---

### 1.4 修复总结表

| 文件 | 原方法 | 新方法 | 变化 |
|------|--------|--------|------|
| `Insight.cs` | `async void SendInsight()` | `async Task SendInsightAsync()` | 返回 Task + 分级 catch |
| `TranslationAndUi.cs` | `async void StartTranslation()` | `async Task StartTranslationAsync()` | 返回 Task + 分类异常 |
| `TranslationAndUi.cs` | `async void StopTranslation()` | `async Task StopTranslationAsync()` | 返回 Task + finally 保证 |
| `ReviewBatch.cs` | `async void GenerateReviewSummary()` | `async Task GenerateReviewSummaryAsync()` | 返回 Task |
| `ReviewBatch.cs` | `async void GenerateAllReviewSheets()` | `async Task GenerateAllReviewSheetsAsync()` | 返回 Task |
| `ReviewBatch.cs` | `async void GenerateSpeechSubtitle()` | `async Task GenerateSpeechSubtitleAsync()` | 返回 Task |
| `ReviewBatch.cs` | `async void GenerateBatchSpeechSubtitle()` | `async Task GenerateBatchSpeechSubtitleAsync()` | 返回 Task |

**命令绑定更新（统一改用 AsyncRelayCommand）：**

```csharp
// Commands.cs 中统一更新
[RelayCommand]
private Task StartTranslation() => StartTranslationAsync();

[RelayCommand]
private Task StopTranslation() => StopTranslationAsync();

[RelayCommand]
private Task GenerateReviewSummary() => GenerateReviewSummaryAsync();
// ... 以此类推
```

---

## 2. 错误处理分级策略

### 2.1 分级定义

```
┌─────────────────────────────────────────────────────────────┐
│ Level 3: Alert（弹窗 / 阻断操作）                            │
│ 适用: 配置丢失、认证失败、致命错误                              │
│ 处理: 弹窗提示 + 记录错误日志 + 阻止后续操作                     │
├─────────────────────────────────────────────────────────────┤
│ Level 2: Notify（状态栏 / 非阻断通知）                        │
│ 适用: 网络超时、API 限流、转写失败                              │
│ 处理: StatusMessage 提示 + 记录警告日志                        │
├─────────────────────────────────────────────────────────────┤
│ Level 1: Silent（静默记录）                                  │
│ 适用: 可自动恢复的错误、后台清理失败、非关键功能异常               │
│ 处理: 仅记录日志，不影响用户体验                                │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 异常类型到级别的映射

| 异常类型 | 级别 | 处理方式 |
|----------|------|----------|
| `OperationCanceledException` | Silent | 忽略或 Debug 日志 |
| `HttpRequestException` | Notify | StatusMessage + Warning 日志 |
| `TaskCanceledException` (超时) | Notify | StatusMessage + Warning 日志 |
| `UnauthorizedAccessException` | Alert | 弹窗 + Error 日志 |
| `FileNotFoundException` | Notify/Alert | 取决于上下文 |
| `JsonException` | Alert | 配置文件损坏，弹窗提示 |
| `InvalidOperationException` | Notify | StatusMessage + Warning 日志 |
| `OutOfMemoryException` | Alert | 弹窗 + 尝试释放资源 |
| `Exception` (通用) | Notify | StatusMessage + Error 日志 |

### 2.3 实现参考代码

```csharp
// 辅助方法：放在 MainWindowViewModel 中
private async Task SafeExecuteAsync(
    Func<Task> action,
    string operationName,
    ErrorLevel defaultLevel = ErrorLevel.Notify)
{
    try
    {
        await action();
    }
    catch (OperationCanceledException)
    {
        _logger?.LogDebug("{Operation} 已取消", operationName);
    }
    catch (HttpRequestException ex)
    {
        HandleError(ex, $"{operationName}: 网络请求失败", ErrorLevel.Notify);
    }
    catch (UnauthorizedAccessException ex)
    {
        HandleError(ex, $"{operationName}: 权限不足", ErrorLevel.Alert);
    }
    catch (Exception ex)
    {
        HandleError(ex, $"{operationName}: 未知错误", defaultLevel);
    }
}

private void HandleError(Exception ex, string message, ErrorLevel level)
{
    _logger?.LogError(ex, message);

    switch (level)
    {
        case ErrorLevel.Silent:
            break;
        case ErrorLevel.Notify:
            StatusMessage = message;
            break;
        case ErrorLevel.Alert:
            // 通过 IDialogService 弹窗
            _ = _dialogService?.ShowMessageAsync("错误", $"{message}\n\n{ex.Message}");
            break;
    }
}

public enum ErrorLevel { Silent, Notify, Alert }
```

**使用示例：**

```csharp
private Task StartTranslationAsync()
    => SafeExecuteAsync(
        async () =>
        {
            StatusMessage = "正在启动翻译...";
            await _speechTranslationService.StartTranslationAsync(...);
            IsTranslating = true;
            StatusMessage = "翻译中";
        },
        "启动翻译");
```

---

## 3. 空 catch 修复清单

### 3.1 MainWindow.axaml.cs（第 17-50 行）

```csharp
// ❌ 当前代码
try
{
    // 窗口初始化逻辑
}
catch { }  // 空 catch

// ✅ 修改后
try
{
    // 窗口初始化逻辑
}
catch (Exception ex)
{
    System.Diagnostics.Debug.WriteLine($"窗口初始化异常: {ex.Message}");
    // 窗口初始化失败不应阻止应用启动
}
```

### 3.2 ReferenceImageCropWindow.axaml.cs

```csharp
// ❌ 当前代码（多处）
try { /* 图片加载 */ }
catch { }

// ✅ 修改后
try { /* 图片加载 */ }
catch (Exception ex)
{
    System.Diagnostics.Debug.WriteLine($"图片加载失败: {ex.Message}");
    // 可选: 显示默认占位图或禁用裁剪功能
}
```

### 3.3 完整扫描结果

需要检查并修复的空 catch 位置（按严重程度排序）：

| 文件 | 位置 | 上下文 | 建议 |
|------|------|--------|------|
| `MainWindow.axaml.cs` | ~17-50 | 窗口初始化 | 添加 Debug 日志 |
| `ReferenceImageCropWindow.axaml.cs` | 多处 | 图片处理 | 添加日志 + UI 反馈 |
| `MediaStudioWindow.axaml.cs` | 事件处理 | 媒体操作 | 添加 StatusMessage |
| `ConfigCenterView.axaml.cs` | 按钮事件 | 配置操作 | 添加日志 + 弹窗 |

---

## 4. 全局异常兜底机制

### 4.1 当前状态

- `CrashLogger` 存在但功能有限
- `Program.cs` 中有基本的异常钩子

### 4.2 增强方案

```csharp
// Program.cs - 增强全局异常处理
public static void Main(string[] args)
{
    // 1. 未处理异常捕获
    AppDomain.CurrentDomain.UnhandledException += (sender, e) =>
    {
        var ex = e.ExceptionObject as Exception;
        CrashLogger.LogFatal(ex, "AppDomain.UnhandledException");
        // 尝试保存用户数据
        TrySaveUserData();
    };

    // 2. Task 未观察异常（async void 的兜底）
    TaskScheduler.UnobservedTaskException += (sender, e) =>
    {
        CrashLogger.LogError(e.Exception, "TaskScheduler.UnobservedTaskException");
        e.SetObserved(); // 防止进程终止
    };

    // 3. Avalonia UI 线程异常
    try
    {
        BuildAvaloniaApp().StartWithClassicDesktopLifetime(args);
    }
    catch (Exception ex)
    {
        CrashLogger.LogFatal(ex, "Application.Run");
        throw;
    }
}
```

---

## 5. CancellationToken 规范化

### 5.1 当前问题

- 部分方法接受 CancellationToken 但不传递给子调用
- CancellationTokenSource 的创建/取消/释放不统一
- 某些长时间操作没有取消支持

### 5.2 规范化要求

**规则 1：所有异步公共方法都应接受 CancellationToken**

```csharp
// ❌ 不推荐
public async Task<string> AnalyzeAsync(string content, string prompt)

// ✅ 推荐
public async Task<string> AnalyzeAsync(string content, string prompt,
    CancellationToken cancellationToken = default)
```

**规则 2：CancellationToken 必须传递给所有子异步调用**

```csharp
public async Task StartTranslationAsync(CancellationToken ct)
{
    await _tokenProvider.GetTokenAsync(resource, ct);     // ✅ 传递
    await httpClient.PostAsync(url, content, ct);          // ✅ 传递
    await Task.Delay(retryDelay, ct);                     // ✅ 传递
}
```

**规则 3：CancellationTokenSource 使用 using 或在 Dispose 中释放**

```csharp
// ✅ 推荐模式
private CancellationTokenSource? _operationCts;

private async Task StartOperationAsync()
{
    // 取消之前的操作
    _operationCts?.Cancel();
    _operationCts?.Dispose();
    _operationCts = new CancellationTokenSource();

    try
    {
        await DoWorkAsync(_operationCts.Token);
    }
    catch (OperationCanceledException) { /* 预期的取消 */ }
}

protected override void OnDispose()
{
    _operationCts?.Cancel();
    _operationCts?.Dispose();
    _operationCts = null;
}
```

### 5.3 需要添加 CancellationToken 支持的方法

| 服务/方法 | 当前状态 | 需要改造 |
|-----------|----------|----------|
| `AiInsightService.AnalyzeAsync` | ✅ 已支持 | — |
| `SpeechTranslationService.StartTranslationAsync` | ✅ 已支持 | — |
| `AiImageGenService.GenerateAsync` | 需确认 | 确保传递到 HTTP 调用 |
| `AiVideoGenService.GenerateAsync` | 需确认 | 确保传递到轮询循环 |
| `BlobStorageService.UploadAsync` | 需确认 | 添加 CancellationToken |
| `AudioFormatConverter.ConvertAsync` | 需确认 | 添加 CancellationToken |

---

## 6. 重试策略建议

### 6.1 适用场景

- Azure API 调用（临时网络故障、429 限流）
- Blob Storage 上传/下载
- Token 刷新

### 6.2 简单重试实现（不引入 Polly）

```csharp
public static class RetryHelper
{
    public static async Task<T> ExecuteWithRetryAsync<T>(
        Func<CancellationToken, Task<T>> action,
        int maxRetries = 3,
        TimeSpan? initialDelay = null,
        CancellationToken ct = default)
    {
        var delay = initialDelay ?? TimeSpan.FromSeconds(1);

        for (int attempt = 0; ; attempt++)
        {
            try
            {
                return await action(ct);
            }
            catch (HttpRequestException ex) when (attempt < maxRetries)
            {
                // 指数退避: 1s, 2s, 4s
                await Task.Delay(delay * Math.Pow(2, attempt), ct);
            }
            catch (TaskCanceledException) when (ct.IsCancellationRequested)
            {
                throw; // 用户取消，不重试
            }
        }
    }
}
```

**使用示例：**

```csharp
var result = await RetryHelper.ExecuteWithRetryAsync(
    ct => _httpClient.GetStringAsync(url, ct),
    maxRetries: 3,
    ct: cancellationToken);
```

### 6.3 特殊情况：Azure 429 限流

```csharp
catch (HttpRequestException ex)
    when (ex.StatusCode == HttpStatusCode.TooManyRequests)
{
    // 从 Retry-After 头获取等待时间
    var retryAfter = response.Headers.RetryAfter?.Delta
        ?? TimeSpan.FromSeconds(30);
    StatusMessage = $"API 限流，{retryAfter.TotalSeconds}秒后重试...";
    await Task.Delay(retryAfter, ct);
}
```

---

## 实施检查清单

### Phase 1（第 1 周）: async void 修复

- [ ] 将 `SendInsight` 改为 `async Task`
- [ ] 将 `StartTranslation` 改为 `async Task`
- [ ] 将 `StopTranslation` 改为 `async Task`
- [ ] 将 `GenerateReviewSummary` 改为 `async Task`
- [ ] 将 `GenerateAllReviewSheets` 改为 `async Task`
- [ ] 将 `GenerateSpeechSubtitle` 改为 `async Task`
- [ ] 将 `GenerateBatchSpeechSubtitle` 改为 `async Task`
- [ ] 更新对应的命令绑定
- [ ] 编译验证，运行时测试

### Phase 2（第 2 周）: 错误处理统一

- [ ] 实现 `SafeExecuteAsync` 辅助方法
- [ ] 修复所有空 catch（4 个文件）
- [ ] 增强 `CrashLogger` 全局兜底
- [ ] 添加 `TaskScheduler.UnobservedTaskException` 处理
- [ ] 规范化所有异常的分级处理

### Phase 3（第 3 周）: CancellationToken 规范化

- [ ] 审查所有异步服务方法的 CancellationToken 支持
- [ ] 确保 CancellationToken 在调用链中正确传递
- [ ] 统一 CancellationTokenSource 的生命周期管理
- [ ] 添加重试辅助工具（可选）
